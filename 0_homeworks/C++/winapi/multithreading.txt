Interlocked___Название_Операции__ - безопасная к потокам операция(+ - / * == != >= ++ -- ...).


------------------------------------------------------------------------
------------------------------------------------------------------------

CriticalSection -  – также один из самых простых механизмов
синхронизации. Критической секцией называется участок кода, который
требует монопольного доступа к разделяемым ресурсам. К недостаткам их
применения можно отнести лишь то, что применять их можно только в
рамках одного процесса, то есть потоки, принадлежащие разным процессам
при помощи критических секций синхронизировать невозможно.
Критические секции позволяют сделать так, чтобы только один поток мог
иметь монопольный доступ к каким-либо общим данным.
Для этого мы должны объявить (обычно как глобальный объект) переменную
типа CRITICAL_SECTION.
Объект этой структуры обязательно должен быть проинициализирован при
помощи InitializeCriticalSection, а по окончании использования освобождён
при помощи DeleteCriticalSection.
Все участки кода, находящиеся между вызовом EnterCriticalSection и
LeaveCriticalSection (для одной и той же секции) гарантировано при
выполнении не будут перекрываться.

CRITICAL_SECTION g_CS;
int N=0;


EnterCriticalSection(&g_CS);
int M=N;
M++;
N=M;
LeaveCriticalSection(&g_CS);

------------------------------------------------------------------------
------------------------------------------------------------------------

Спинлок - низкоуровневый примитив синхронизации, применяемый в многопроцессорных системах для реализации взаимного исключения (мьютекса)

Физически спинлок представляет собой переменную в памяти и реализуется на атомарных операциях, которые должны присутствовать в системе команд процессора. Каждый процессор, желающий получить доступ к разделяемому ресурсу, атомарно записывает условное значение «занято» в эту переменную, используя аналог операции swap (в архитектуре x86 — xchg). Если предыдущее значение переменной (возвращаемое командой) было «свободно» то считается, что данный процессор получил доступ к ресурсу, в противном случае процессор возвращается к операции swap и крутится в цикле, ожидая, пока спинлок будет освобождён. После работы с разделяемым ресурсом процессор-владелец спинлока должен записать в него условное значение «свободно».

Пример:
int N=0;
bool flag=true;

void f(){
	flag=false;
	while(flag); 
	int M=N;
	M++;
	N=M;
	flag=true;
}

------------------------------------------------------------------------
------------------------------------------------------------------------

Мьютекс — («взаимное исключение») — аналог одноместного семафора, служащий в программировании для синхронизации одновременно выполняющихся потоков.

Мьютексы — это простейшие двоичные семафоры, которые могут находиться в одном из двух состояний — отмеченном или неотмеченном (открыт и закрыт соответственно). Когда какой-либо поток, принадлежащий любому процессу, становится владельцем объекта mutex, последний переводится в неотмеченное состояние. Если задача освобождает мьютекс, его состояние становится отмеченным.

Задача мьютекса — защита объекта от доступа к нему других потоков, отличных от того, который завладел мьютексом. В каждый конкретный момент только один поток может владеть объектом, защищённым мьютексом. Если другому потоку будет нужен доступ к переменной, защищённой мьютексом, то этот поток блокируется до тех пор, пока мьютекс не будет освобождён.



int _tmain(int argc, _TCHAR* argv[]){
	HANDLE hMutex = CreateMutex(0,TRUE,_T("Mutex!"));
	if(GetLastError() == ERROR_ALREADY_EXISTS){
		CloseHandle(hMutex);
		MessageBox(NULL,_T("Already open"), _T("Error"), MB_OK | MB_ICONERROR | MB_TOPMOST );
		return -1;
	}
	MessageBox(NULL,_T("Open!"), _T(""), MB_OK | MB_TOPMOST );
	return 0;
}

------------------------------------------------------------------------
------------------------------------------------------------------------

Семафор  — объект, ограничивающий количество потоков, которые могут войти в заданный участок кода. Определение введено Эдсгером Дейкстрой в 1962 или 1963 году[1]. Семафоры используются для синхронизации и защиты передачи данных через разделяемую память, а также для синхронизации работы процессов и потоков.
//Следующий пример показывает, как наладить поочерёдный доступ к консоли.
auto semName = TEXT("Semaphore123");
CreateSemaphore(NULL, 0, 1, semName );

// Поток 1:
auto sem = OpenSemaphore(NULL, true, semName);
cout << "Состояние массива: ";
for (int i=0; i<n; i++)
    cout << a[i] << ' ';
cout << '\n';
ReleaseSemaphore(semName, 1, NULL);

// Поток 2:
auto sem = OpenSemaphore(NULL, true, semName);
cout << "Нажато Esc.\n";
ReleaseSemaphore(semName, 1, NULL);